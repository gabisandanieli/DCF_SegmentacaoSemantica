# -*- coding: utf-8 -*-
"""11913509_TCC_Unet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a_PKxadXDBYQkeCHL9VNNPN3GpJQ3BfX

**Gabriela Sandanieli de Aguiar (11913509) - Engenharia de Computa√ß√£o - USP S√£o Carlos**

# **U-Net**
"""

# Monta o Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Importa√ß√µes principais
import numpy as np
import os
import cv2
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

# Modelagem e Keras
import tensorflow as tf
from tensorflow.keras import layers, models
import tensorflow.keras.backend as K
from keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint

# Valida√ß√£o cruzada e estat√≠sticas
from sklearn.model_selection import StratifiedKFold
from collections import Counter
from sklearn.metrics import (
    roc_curve, auc, precision_recall_curve, confusion_matrix,
    precision_score, recall_score, f1_score, jaccard_score,
    ConfusionMatrixDisplay
)

# Fun√ß√£o de carregamento das imagens e m√°scaras
def load_full_dataset(base_dir):
    X, Y = [], []

    for sub in sorted(os.listdir(base_dir)):
        flair_dir = os.path.join(base_dir, sub, "flair")
        mask_dir = os.path.join(base_dir, sub, "mask")

        for flair_file in sorted(os.listdir(flair_dir)):
            flair_path = os.path.join(flair_dir, flair_file)
            flair_img = cv2.imread(flair_path, cv2.IMREAD_GRAYSCALE).astype(np.float32) / 255.0
            flair_img = np.expand_dims(flair_img, axis=-1)

            mask_img = np.zeros((256, 256), dtype=np.float32)

            if os.path.exists(mask_dir):
                mask_file = flair_file.replace("slice", "mask")
                mask_path = os.path.join(mask_dir, mask_file)

                if os.path.exists(mask_path):
                    mask_img = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
                    mask_img = (mask_img > 127).astype(np.float32)
            mask_img = np.expand_dims(mask_img, axis=-1)

            X.append(flair_img)
            Y.append(mask_img)
    return np.array(X), np.array(Y)

# Caminho base onde est√£o armazenadas as pastas com as imagens
base_dir = '/content/drive/MyDrive/TCC/slices_subs'

# Carrega o dataset completo (imagens FLAIR e m√°scaras bin√°rias)
X, Y = load_full_dataset(base_dir)

np.save("/content/drive/MyDrive/TCC/ResultadosUnet/X_tcc.npy", X)
np.save("/content/drive/MyDrive/TCC/ResultadosUnet/Y_tcc.npy", Y)

X = np.load("/content/drive/MyDrive/TCC/ResultadosUnet/X_tcc.npy")
Y = np.load("/content/drive/MyDrive/TCC/ResultadosUnet/Y_tcc.npy")

# Confirma o shape esperado
print("‚úÖ Dataset carregado:")
print("X:", X.shape)
print("Y:", Y.shape)

# Conta o n√∫mero de pixels com les√£o em cada imagem
lesion_pixel_counts = np.array([np.sum(y) for y in Y])

# Define n√≠veis de les√£o com base na quantidade de pixels
# 4 faixas para estratifica√ß√£o: 0 (sem les√£o), 1 (leve), 2 (m√©dia), 3 (alta)
lesion_levels = []
for count in lesion_pixel_counts:
    if count == 0:
        lesion_levels.append(0)
    elif count < 100:
        lesion_levels.append(1)
    elif count < 1000:
        lesion_levels.append(2)
    else:
        lesion_levels.append(3)
lesion_levels = np.array(lesion_levels)

print("\nüìä Distribui√ß√£o das classes para estratifica√ß√£o (completa):")
print(Counter(lesion_levels))

# Separa dados para teste final (20% do total), com estratifica√ß√£o
from sklearn.model_selection import train_test_split

X_trainval, X_test, Y_trainval, Y_test, levels_trainval, levels_test = train_test_split(
    X, Y, lesion_levels, test_size=0.2, stratify=lesion_levels, random_state=42
)

print("\nüìä Distribui√ß√£o das classes para treino/valida√ß√£o:")
print(Counter(levels_trainval))

print("\nüìä Distribui√ß√£o das classes para teste final:")
print(Counter(levels_test))

# Define os folds estratificados a partir do conjunto de treino/valida√ß√£o
skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
folds = list(skf.split(X_trainval, levels_trainval))

# Mostra a distribui√ß√£o de classes em cada fold
for i, (_, val_idx) in enumerate(folds):
    val_classes = levels_trainval[val_idx]
    print(f"\nüîÅ Fold {i+1}")
    print(" - Valida√ß√£o - Distribui√ß√£o das classes:", dict(Counter(val_classes)))

# Fun√ß√£o para criar a arquitetura U-Net
def unet_model(input_size=(256, 256, 1)):
    inputs = tf.keras.Input(input_size)

    # Encoder
    c1 = layers.Conv2D(16, (3, 3), activation='relu', padding='same')(inputs)
    c1 = layers.Conv2D(16, (3, 3), activation='relu', padding='same')(c1)
    p1 = layers.MaxPooling2D((2, 2))(c1)

    c2 = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(p1)
    c2 = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(c2)
    p2 = layers.MaxPooling2D((2, 2))(c2)

    c3 = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(p2)
    c3 = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(c3)
    p3 = layers.MaxPooling2D((2, 2))(c3)

    c4 = layers.Conv2D(128, (3, 3), activation='relu', padding='same')(p3)
    c4 = layers.Conv2D(128, (3, 3), activation='relu', padding='same')(c4)

    # Decoder
    u1 = layers.UpSampling2D((2, 2))(c4)
    u1 = layers.Concatenate()([u1, c3])
    c5 = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(u1)
    c5 = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(c5)

    u2 = layers.UpSampling2D((2, 2))(c5)
    u2 = layers.Concatenate()([u2, c2])
    c6 = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(u2)
    c6 = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(c6)

    u3 = layers.UpSampling2D((2, 2))(c6)
    u3 = layers.Concatenate()([u3, c1])
    c7 = layers.Conv2D(16, (3, 3), activation='relu', padding='same')(u3)
    c7 = layers.Conv2D(16, (3, 3), activation='relu', padding='same')(c7)

    outputs = layers.Conv2D(1, (1, 1), activation='sigmoid')(c7)
    return models.Model(inputs, outputs)

# M√©trica de Dice (usada como m√©trica e parte da perda)
def dice_coef(y_true, y_pred, smooth=1e-6):
    y_true_f = K.flatten(y_true)
    y_pred_f = K.flatten(y_pred)
    intersection = K.sum(y_true_f * y_pred_f)
    return (2. * intersection + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)

# Fun√ß√£o de perda: Binary Crossentropy ponderada por pixel
def weighted_bce(y_true, y_pred):
    weight = 50.0  # Peso alto para valorizar mais os pixels de les√£o
    bce = K.binary_crossentropy(y_true, y_pred)
    weight_vector = y_true * weight + (1. - y_true)
    return K.mean(bce * weight_vector)

# Combina√ß√£o da perda BCE ponderada + Dice
def combined_loss(y_true, y_pred):
    return 0.5 * weighted_bce(y_true, y_pred) + 0.5 * (1 - dice_coef(y_true, y_pred))

histories = []      # Hist√≥rico por fold
fold_metrics = []   # M√©tricas globais por fold

# Fun√ß√£o Dice usada para avalia√ß√£o fora do modelo
def dice_score(y_true, y_pred, smooth=1e-6):
    y_true_f = y_true.flatten()
    y_pred_f = y_pred.flatten()
    intersection = np.sum(y_true_f * y_pred_f)
    return (2. * intersection + smooth) / (np.sum(y_true_f) + np.sum(y_pred_f) + smooth)

# Loop de treinamento com K-Fold
for fold, (train_idx, val_idx) in enumerate(folds):
    print(f"\nüîÅ Treinando Fold {fold+1}/{len(folds)}")

    # Divis√£o dos dados para este fold
    X_train, X_val = X_trainval[train_idx], X_trainval[val_idx]
    Y_train, Y_val = Y_trainval[train_idx], Y_trainval[val_idx]

    # Instancia novo modelo U-Net e compila
    model = unet_model()
    model.compile(optimizer='adam', loss=combined_loss, metrics=[dice_coef])

    # Diret√≥rio para salvar melhor modelo por fold
    ckpt_path = f"/content/drive/MyDrive/TCC/ResultadosUnet/model_fold{fold+1}.keras"

    callbacks = [
        ModelCheckpoint(ckpt_path, save_best_only=True, monitor="val_loss", verbose=0),
        EarlyStopping(patience=10, monitor="val_loss", restore_best_weights=True),
        ReduceLROnPlateau(patience=5, factor=0.5, min_lr=1e-6, verbose=1)
    ]

    # Treinamento
    history = model.fit(
        X_train, Y_train,
        validation_data=(X_val, Y_val),
        epochs=100,
        batch_size=8,
        callbacks=callbacks
    )

    # Salva hist√≥rico do treinamento
    histories.append(history.history)

    # Avalia√ß√£o nas predi√ß√µes
    y_pred = model.predict(X_val) > 0.6

    # Calcula m√©tricas por fold
    dice = dice_score(Y_val, y_pred)
    iou = jaccard_score(Y_val.flatten(), y_pred.flatten(), zero_division=0)
    recall = recall_score(Y_val.flatten(), y_pred.flatten(), zero_division=0)
    precision = precision_score(Y_val.flatten(), y_pred.flatten(), zero_division=0)
    f1 = f1_score(Y_val.flatten(), y_pred.flatten(), zero_division=0)

    print(f"‚úîÔ∏è Fold {fold+1} - Dice: {dice:.4f}, IoU: {iou:.4f}, Recall: {recall:.4f}, Precision: {precision:.4f}, F1: {f1:.4f}")

    # Armazena m√©tricas por fold
    fold_metrics.append({
        'fold': fold + 1,
        'dice': dice,
        'iou': iou,
        'recall': recall,
        'precision': precision,
        'f1': f1
    })

    # Cria diret√≥rio para este fold e salva os dados de valida√ß√£o e predi√ß√£o
    fold_dir = f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold+1}"
    os.makedirs(fold_dir, exist_ok=True)
    np.save(os.path.join(fold_dir, "X_val.npy"), X_val)
    np.save(os.path.join(fold_dir, "Y_val.npy"), Y_val)
    np.save(os.path.join(fold_dir, "Y_pred.npy"), y_pred.astype(np.uint8))

# Salvar em CSV
df_metrics = pd.DataFrame(fold_metrics)
df_metrics.to_csv("/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/metricas_por_fold.csv", index=False)

# Plot de slices para visualiza√ß√£o das predi√ß√µes durante o treino
fold_num = 1

X_val = np.load(f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold_num}/X_val.npy")
Y_val = np.load(f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold_num}/Y_val.npy")
Y_pred = np.load(f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold_num}/Y_pred.npy")

# Visualiza√ß√£o de 20 slices aleat√≥rias
for i in range(20):
    plt.figure(figsize=(12,4))

    plt.subplot(1,3,1)
    plt.title("FLAIR")
    plt.imshow(X_val[i].squeeze(), cmap='viridis')
    plt.axis('off')

    plt.subplot(1,3,2)
    plt.title("M√°scara Real")
    plt.imshow(Y_val[i].squeeze(), cmap='viridis')
    plt.axis('off')

    plt.subplot(1,3,3)
    plt.title("Predi√ß√£o Bin√°ria")
    plt.imshow(Y_pred[i].squeeze(), cmap='viridis')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

"""# **Gr√°ficos U-Net**"""

# An√°lise qualitativa
def analyze_saved_fold(fold_dir, fold_number):
    # Carrega os dados
    X_val = np.load(os.path.join(fold_dir, "X_val.npy"))
    Y_val = np.load(os.path.join(fold_dir, "Y_val.npy"))
    Y_pred = np.load(os.path.join(fold_dir, "Y_pred.npy"))

    print(f"\nüîç An√°lise qualitativa - Fold {fold_number}")

    def calculate_all_metrics(y_true, y_pred):
        cm = confusion_matrix(y_true.flatten(), y_pred.flatten(), labels=[0,1])
        precision = precision_score(y_true.flatten(), y_pred.flatten(), zero_division=0)
        recall = recall_score(y_true.flatten(), y_pred.flatten(), zero_division=0)
        f1 = f1_score(y_true.flatten(), y_pred.flatten(), zero_division=0)
        iou = jaccard_score(y_true.flatten(), y_pred.flatten(), zero_division=0)
        dice = dice_score(y_true, y_pred)
        return cm, dice, iou, recall, precision, f1

    def plot_case_unet(idx, title_extra=''):
        flair = X_val[idx].squeeze()
        mask_true = Y_val[idx].squeeze()
        pred_bin = Y_pred[idx].squeeze()

        cm, dice, iou, recall, precision, f1 = calculate_all_metrics(mask_true, pred_bin)

        plt.figure(figsize=(15, 4))
        plt.subplot(1, 4, 1)
        plt.title("FLAIR")
        plt.imshow(flair, cmap='viridis')
        plt.axis('off')

        plt.subplot(1, 4, 2)
        plt.title("M√°scara Real")
        plt.imshow(mask_true, cmap='viridis')
        plt.axis('off')

        plt.subplot(1, 4, 3)
        plt.title(f"Predi√ß√£o\nDice: {dice:.4f}")
        plt.imshow(pred_bin, cmap='viridis')
        plt.axis('off')

        plt.subplot(1, 4, 4)
        sns.heatmap(cm, annot=True, fmt='d', cmap='Purples', xticklabels=['Fundo', 'Les√£o'], yticklabels=['Fundo', 'Les√£o'])
        plt.title(f"Matriz de Confus√£o\n{title_extra}")
        plt.xlabel("Predito")
        plt.ylabel("Real")

        plt.tight_layout()
        plt.show()

        print(f"Dice: {dice:.4f}, IoU: {iou:.4f}, Recall: {recall:.4f}, Precision: {precision:.4f}, F1: {f1:.4f}")

    # Calcula por slice
    lesion_pixels_per_slice = np.array([np.sum(mask > 0) for mask in Y_val])
    dice_per_slice = np.array([dice_score(Y_val[i], Y_pred[i]) for i in range(len(Y_val))])

    # Caso 1: Sem les√£o e predi√ß√£o correta
    no_lesion_cases = np.where(lesion_pixels_per_slice == 0)[0]
    valid_no_lesion = [i for i in no_lesion_cases if np.sum(Y_pred[i]) == 0]
    if valid_no_lesion:
        plot_case_unet(valid_no_lesion[0], title_extra="Sem Les√£o - Predi√ß√£o Correta")

    # Caso 2: Les√£o pequena
    lesion_small = np.where((lesion_pixels_per_slice > 200) & (lesion_pixels_per_slice < 400))[0]
    if len(lesion_small) > 0:
        plot_case_unet(lesion_small[0], title_extra="Les√£o Pequena")

    # Caso 3: Maior les√£o
    plot_case_unet(np.argmax(lesion_pixels_per_slice), title_extra="Maior Les√£o")

    # Caso 4: Maior Dice
    cases_with_lesion = np.where(lesion_pixels_per_slice > 0)[0]
    if len(cases_with_lesion) > 0:
        idx_best_dice = cases_with_lesion[np.argmax(dice_per_slice[cases_with_lesion])]
        plot_case_unet(idx_best_dice, title_extra="Maior Dice com Les√£o")

for i in range(1, 6):
    fold_path = f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{i}"
    analyze_saved_fold(fold_path, i)

# Plot scatter por fold
for fold in range(1, 6):
    path = f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold}"
    Y_val = np.load(f"{path}/Y_val.npy")
    Y_pred = np.load(f"{path}/Y_pred.npy")

    lesion_sizes = []
    dice_scores = []

    for i in range(len(Y_val)):
        true_mask = Y_val[i].squeeze()
        pred_mask = Y_pred[i].squeeze()
        lesion_size = np.sum(true_mask > 0)
        dice = dice_score(true_mask, pred_mask)
        if lesion_size > 0:
            lesion_sizes.append(lesion_size)
            dice_scores.append(dice)

    # Plot individual por fold
    plt.figure(figsize=(7,5))
    plt.scatter(lesion_sizes, dice_scores, alpha=0.6, color='tab:purple')
    plt.title(f"Fold {fold} - Dice vs Tamanho da Les√£o")
    plt.xlabel("Tamanho da Les√£o (pixels)")
    plt.ylabel("Dice Score")
    plt.grid(True)
    plt.show()

# Plot curva roc e precision-recall
for fold in range(1, 6):
    print(f"\nFold {fold}:")

    path = f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold}"
    Y_val = np.load(f"{path}/Y_val.npy").flatten()
    Y_probs = np.load(f"{path}/Y_pred.npy").flatten()

    # ROC Curve
    fpr, tpr, _ = roc_curve(Y_val, Y_probs)
    roc_auc = auc(fpr, tpr)

    plt.figure(figsize=(8, 5))
    plt.plot(fpr, tpr, label=f'ROC AUC = {roc_auc:.4f}', color='tab:purple')
    plt.plot([0, 1], [0, 1], 'k--', label='Aleat√≥rio')
    plt.title(f'Curva ROC - Fold {fold} (por pixel)')
    plt.xlabel('FPR')
    plt.ylabel('TPR')
    plt.legend()
    plt.grid()
    plt.show()

    # Precision-Recall Curve
    precision, recall, _ = precision_recall_curve(Y_val, Y_probs)
    pr_auc = auc(recall, precision)

    plt.figure(figsize=(8, 5))
    plt.plot(recall, precision, label=f'PR AUC = {pr_auc:.4f}', color='tab:purple')
    plt.title(f'Curva Precision-Recall - Fold {fold} (por pixel)')
    plt.xlabel('Recall')
    plt.ylabel('Precision')
    plt.legend()
    plt.grid()
    plt.show()

    print(f"‚úîÔ∏è AUC ROC: {roc_auc:.4f} | AUC PR: {pr_auc:.4f}")

# Plot qualitativo com mapa de erro
def plot_case_qualitativo(x, y_true, y_prob, idx, title_extra=''):
    flair = x[idx].squeeze()
    mask_true = y_true[idx].squeeze()
    pred_probs = y_prob[idx].squeeze()
    pred_bin = (pred_probs > 0.6).astype(np.uint8)

    # M√©tricas
    cm = confusion_matrix(mask_true.flatten(), pred_bin.flatten(), labels=[0, 1])
    dice = dice_score(mask_true, pred_bin)
    iou = jaccard_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
    recall = recall_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
    precision = precision_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
    f1 = f1_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)

    # Mapa de erro colorido
    intersection = np.logical_and(mask_true == 1, pred_bin == 1)
    false_positive = np.logical_and(mask_true == 0, pred_bin == 1)
    false_negative = np.logical_and(mask_true == 1, pred_bin == 0)
    error_map = np.zeros((*mask_true.shape, 3), dtype=np.uint8)
    error_map[intersection] = [0, 255, 0]
    error_map[false_positive] = [255, 0, 0]
    error_map[false_negative] = [0, 0, 255]

    # Plot
    plt.figure(figsize=(18, 5))
    plt.subplot(1, 4, 1)
    plt.title("FLAIR")
    plt.imshow(flair, cmap='gray')
    plt.axis('off')

    plt.subplot(1, 4, 2)
    plt.title(f"M√°scara Real\nPixels: {np.sum(mask_true)}")
    plt.imshow(mask_true, cmap='gray')
    plt.axis('off')

    plt.subplot(1, 4, 3)
    plt.title(f"Predi√ß√£o\nDice: {dice:.4f}\nIoU: {iou:.4f}")
    plt.imshow(pred_bin, cmap='gray')
    plt.axis('off')

    plt.subplot(1, 4, 4)
    plt.title("Mapa de Erro\nVerde: TP | Vermelho: FP | Azul: FN")
    plt.imshow(error_map)
    plt.axis('off')

    plt.suptitle(title_extra, fontsize=16)
    plt.show()

    print(f"Dice: {dice:.4f}, IoU: {iou:.4f}, Recall: {recall:.4f}, Precision: {precision:.4f}, F1: {f1:.4f}")

# Loop por fold
for fold in range(1, 6):
    print(f"\nüîç Fold {fold}")

    # Carrega os dados
    path = f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold}"
    X_val = np.load(f"{path}/X_val.npy")
    Y_val = np.load(f"{path}/Y_val.npy")
    Y_pred = np.load(f"{path}/Y_pred.npy")

    lesion_pixels = np.array([np.sum(y) for y in Y_val])
    dice_scores = np.array([
        dice_score(Y_val[i].squeeze(), (Y_pred[i].squeeze() > 0.6).astype(np.uint8))
        for i in range(len(Y_val))
    ])

    # Caso 1 ‚Äì Sem les√£o e fundo predito corretamente
    no_lesion = np.where(lesion_pixels == 0)[0]
    correct_bg = [i for i in no_lesion if np.sum((Y_pred[i].squeeze() > 0.6)) == 0]
    if correct_bg:
        plot_case_qualitativo(X_val, Y_val, Y_pred, correct_bg[0], title_extra='Fold {}: Sem Les√£o'.format(fold))

    # Caso 2 ‚Äì Les√£o pequena
    small_lesion = np.where((lesion_pixels > 200) & (lesion_pixels < 400))[0]
    if len(small_lesion) > 0:
        plot_case_qualitativo(X_val, Y_val, Y_pred, small_lesion[0], title_extra='Fold {}: Les√£o Pequena'.format(fold))

    # Caso 3 ‚Äì Maior les√£o
    largest_idx = np.argmax(lesion_pixels)
    plot_case_qualitativo(X_val, Y_val, Y_pred, largest_idx, title_extra='Fold {}: Maior Les√£o'.format(fold))

    # Caso 4 ‚Äì Melhor Dice em slice com les√£o
    with_lesion = np.where(lesion_pixels > 0)[0]
    if len(with_lesion) > 0:
        best_dice_idx = with_lesion[np.argmax(dice_scores[with_lesion])]
        plot_case_qualitativo(X_val, Y_val, Y_pred, best_dice_idx, title_extra='Fold {}: Maior Dice'.format(fold))

# Matriz de Confus√£o (por Slice)
threshold = 0.6

for fold in range(1, 6):
    print(f"\nüîç Fold {fold}")
    fold_path = f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold}"

    X_val = np.load(f"{fold_path}/X_val.npy")
    Y_val = np.load(f"{fold_path}/Y_val.npy")
    Y_pred = np.load(f"{fold_path}/Y_pred.npy")

    y_true_slice = []
    y_pred_slice = []

    for i in range(len(X_val)):
        mask_true = Y_val[i].squeeze()
        pred_probs = Y_pred[i].squeeze()
        pred_bin = (pred_probs > threshold).astype(np.uint8)

        has_lesion_gt = int(np.sum(mask_true) > 0)
        has_lesion_pred = int(np.sum(pred_bin) > 0)

        y_true_slice.append(has_lesion_gt)
        y_pred_slice.append(has_lesion_pred)

    cm_slice = confusion_matrix(y_true_slice, y_pred_slice, labels=[0, 1])

    disp = ConfusionMatrixDisplay(confusion_matrix=cm_slice, display_labels=["Fundo", "Les√£o"])
    disp.plot(cmap='Purples', values_format='d')
    plt.title(f"Matriz de Confus√£o (por Slice) - Fold {fold}")
    plt.grid(False)
    plt.show()

# Matriz de Confus√£o Normalizada (Pixel)
threshold = 0.6

for fold in range(1, 6):
    print(f"\nüîç Fold {fold}")
    fold_path = f"/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/fold{fold}"

    # Carrega dados salvos
    Y_val = np.load(f"{fold_path}/Y_val.npy")
    Y_pred = np.load(f"{fold_path}/Y_pred.npy")

    # Flatten de todas as slices
    all_y_true = np.concatenate([Y_val[i].flatten() for i in range(len(Y_val))])
    all_y_probs = np.concatenate([Y_pred[i].flatten() for i in range(len(Y_pred))])

    # Binariza
    all_y_pred = (all_y_probs > threshold).astype(np.uint8)

    # Matriz de confus√£o
    cm_pixel = confusion_matrix(all_y_true, all_y_pred, labels=[0, 1])

    # Normaliza por linha (evita distor√ß√µes por classe majorit√°ria)
    cm_norm = cm_pixel.astype('float') / cm_pixel.sum(axis=1, keepdims=True)

    # Exibe
    sns.heatmap(cm_norm, annot=True, cmap='Purples', fmt='.2f',
                xticklabels=['Fundo', 'Les√£o'], yticklabels=['Fundo', 'Les√£o'])
    plt.title(f"Matriz de Confus√£o Normalizada (Pixel) - Fold {fold} | Threshold {threshold}")
    plt.xlabel("Predito")
    plt.ylabel("Real")
    plt.show()

for fold, hist in enumerate(histories):
    epochs = np.arange(1, len(hist['loss']) + 1)
    mark_epochs = np.array([1] + list(range(5, len(hist['loss']) + 1, 5)))

    # DICE
    plt.figure(figsize=(8, 4))
    plt.plot(epochs, hist['dice_coef'], label='Dice Treino', color='tab:purple', marker='o', markevery=mark_epochs - 1)
    plt.plot(epochs, hist['val_dice_coef'], label='Dice Valida√ß√£o', color='tab:green', marker='s', markevery=mark_epochs - 1)
    plt.title(f'Fold {fold+1} - Curva de Dice')
    plt.xlabel('√âpoca')
    plt.ylabel('Dice')
    plt.legend()
    plt.grid()
    plt.tight_layout()
    plt.show()

    # LOSS
    plt.figure(figsize=(8, 4))
    plt.plot(epochs, hist['loss'], label='Loss Treino', color='tab:purple', marker='o', markevery=mark_epochs - 1)
    plt.plot(epochs, hist['val_loss'], label='Loss Valida√ß√£o', color='tab:green', marker='s', markevery=mark_epochs - 1)
    plt.title(f'Fold {fold+1} - Curva de Loss')
    plt.xlabel('√âpoca')
    plt.ylabel('Loss')
    plt.legend()
    plt.grid()
    plt.tight_layout()
    plt.show()

import numpy as np
import matplotlib.pyplot as plt

def moving_average(data, window=5):
    return np.convolve(data, np.ones(window)/window, mode='valid')

for fold, hist in enumerate(histories):
    epochs = np.arange(1, len(hist['loss']) + 1)

    # M√©dia m√≥vel
    window = 5
    sm_dice_train = moving_average(hist['dice_coef'], window=window)
    sm_dice_val = moving_average(hist['val_dice_coef'], window=window)
    sm_loss_train = moving_average(hist['loss'], window=window)
    sm_loss_val = moving_average(hist['val_loss'], window=window)

    # Compensa o deslocamento da m√©dia
    sm_epochs = np.arange(window//2 + 1, len(hist['loss']) - (window//2) + 1)

    # Define √©pocas com marcador: 1, 5, 10...
    marker_epochs = [e for e in sm_epochs if e == 1 or e % 5 == 0]
    marker_indices = [np.where(sm_epochs == me)[0][0] for me in marker_epochs]

    # üéØ DICE
    plt.figure(figsize=(8, 4))
    plt.plot(sm_epochs, sm_dice_train, color='tab:purple', label='Dice Treino')
    plt.plot(sm_epochs[marker_indices], sm_dice_train[marker_indices], 'o', color='tab:purple', label=None)

    plt.plot(sm_epochs, sm_dice_val, color='tab:green', label='Dice Valida√ß√£o')
    plt.plot(sm_epochs[marker_indices], sm_dice_val[marker_indices], 's', color='tab:green', label=None)

    plt.title(f'Fold {fold+1} - Curva de Dice (Suavizada)')
    plt.xlabel('√âpoca')
    plt.ylabel('Dice')
    plt.legend()
    plt.ylim(0, 1)
    plt.grid()
    plt.tight_layout()
    plt.show()

    # üìâ LOSS
    plt.figure(figsize=(8, 4))
    plt.plot(sm_epochs, sm_loss_train, color='tab:purple', label='Loss Treino')
    plt.plot(sm_epochs[marker_indices], sm_loss_train[marker_indices], 'o', color='tab:purple', label=None)

    plt.plot(sm_epochs, sm_loss_val, color='tab:green', label='Loss Valida√ß√£o')
    plt.plot(sm_epochs[marker_indices], sm_loss_val[marker_indices], 's', color='tab:green', label=None)

    plt.title(f'Fold {fold+1} - Curva de Loss (Suavizada)')
    plt.xlabel('√âpoca')
    plt.ylabel('Loss')
    plt.legend()
    plt.grid()
    plt.tight_layout()
    plt.show()

# Curva de Loss e Dice M√©dia com Desvio Padr√£o
max_epochs = min(len(h['loss']) for h in histories)
loss_train = np.array([h['loss'][:max_epochs] for h in histories])
loss_val = np.array([h['val_loss'][:max_epochs] for h in histories])
dice_train = np.array([h['dice_coef'][:max_epochs] for h in histories])
dice_val = np.array([h['val_dice_coef'][:max_epochs] for h in histories])
epochs = np.arange(1, max_epochs + 1)

plt.figure(figsize=(8,5))
plt.plot(epochs, loss_train.mean(axis=0), label='Loss Treino (m√©dia)', color='purple')
plt.fill_between(epochs, loss_train.mean(axis=0) - loss_train.std(axis=0),
                          loss_train.mean(axis=0) + loss_train.std(axis=0), alpha=0.2)
plt.plot(epochs, loss_val.mean(axis=0), label='Loss Valida√ß√£o (m√©dia)', color='green')
plt.fill_between(epochs, loss_val.mean(axis=0) - loss_val.std(axis=0),
                          loss_val.mean(axis=0) + loss_val.std(axis=0), alpha=0.2)
plt.title("Curva de Loss M√©dia com Desvio Padr√£o")
plt.xlabel("√âpocas")
plt.ylabel("Loss")
plt.legend()
plt.grid()
plt.show()

plt.figure(figsize=(8,5))
plt.plot(epochs, dice_train.mean(axis=0), label='Dice Treino (m√©dia)', color='purple')
plt.fill_between(epochs, dice_train.mean(axis=0) - dice_train.std(axis=0),
                          dice_train.mean(axis=0) + dice_train.std(axis=0), alpha=0.2)
plt.plot(epochs, dice_val.mean(axis=0), label='Dice Valida√ß√£o (m√©dia)', color='green')
plt.fill_between(epochs, dice_val.mean(axis=0) - dice_val.std(axis=0),
                          dice_val.mean(axis=0) + dice_val.std(axis=0), alpha=0.2)
plt.title("Curva de Dice M√©dia com Desvio Padr√£o")
plt.xlabel("√âpocas")
plt.ylabel("Dice")
plt.legend()
plt.grid()
plt.show()

"""# **Teste Final**"""

# üîç Avalia√ß√£o no conjunto de teste final
print("\n‚úÖ Avalia√ß√£o no Teste Final")
final_model = unet_model()
final_model.compile(optimizer='adam', loss=combined_loss, metrics=[dice_coef])
history_final = final_model.fit(X_trainval, Y_trainval, epochs=100, batch_size=8)

y_test_pred = final_model.predict(X_test) > 0.6
Y_probs_test = final_model.predict(X_test)

np.save("/content/drive/MyDrive/TCC/ResultadosUnet/X_test.npy", X_test)
np.save("/content/drive/MyDrive/TCC/ResultadosUnet/Y_test.npy", Y_test)
np.save("/content/drive/MyDrive/TCC/ResultadosUnet/Y_pred_test.npy", y_test_pred.astype(np.uint8))
np.save("/content/drive/MyDrive/TCC/ResultadosUnet/Y_probs_test.npy", Y_probs_test)

dice_test = dice_score(Y_test, y_test_pred)
iou_test = jaccard_score(Y_test.flatten(), y_test_pred.flatten(), zero_division=0)
recall_test = recall_score(Y_test.flatten(), y_test_pred.flatten(), zero_division=0)
precision_test = precision_score(Y_test.flatten(), y_test_pred.flatten(), zero_division=0)
f1_test = f1_score(Y_test.flatten(), y_test_pred.flatten(), zero_division=0)

print(f"\nüîç Teste Final - Dice: {dice_test:.4f}, IoU: {iou_test:.4f}, Recall: {recall_test:.4f}, Precision: {precision_test:.4f}, F1: {f1_test:.4f}")

# L√™ o CSV salvo com as m√©tricas dos folds
csv_path = "/content/drive/MyDrive/TCC/ResultadosUnet/fold_outputs/metricas_por_fold.csv"
df_folds = pd.read_csv(csv_path)

# Usa as m√©tricas do teste final j√° calculadas
df_test = pd.DataFrame([{
    'fold': 'Teste Final',
    'dice': dice_test,
    'iou': iou_test,
    'recall': recall_test,
    'precision': precision_test,
    'f1': f1_test
}])

# Calcula m√©dia dos folds
df_folds_only = df_folds[~df_folds['fold'].astype(str).str.lower().str.contains("teste")]
media_row = df_folds_only.mean(numeric_only=True)
media_row['fold'] = 'M√©dia (Folds)'

df_final = pd.concat([df_folds_only, pd.DataFrame([media_row]), df_test], ignore_index=True)

print("üîç Tabela Final com Folds, M√©dia e Teste Final:")
display(df_final.round(4))

# Visualiza√ß√£o das predi√ß√µes do modelo em algumas slices do teste
Y_pred_bin_test = (Y_probs_test > 0.6).astype(np.uint8)

for i in range(20):
    plt.figure(figsize=(12,4))
    plt.subplot(1,3,1)
    plt.title("FLAIR")
    plt.imshow(X_test[i].squeeze(), cmap='viridis')
    plt.axis('off')

    plt.subplot(1,3,2)
    plt.title("M√°scara Real")
    plt.imshow(Y_test[i].squeeze(), cmap='viridis')
    plt.axis('off')

    plt.subplot(1,3,3)
    plt.title("Predi√ß√£o Bin√°ria")
    plt.imshow(Y_pred_bin_test[i].squeeze(), cmap='viridis')
    plt.axis('off')

    plt.show()

# Gr√°ficos de loss e dice
epochs = range(1, len(history_final.history['loss']) + 1)

# Loss
plt.figure(figsize=(8,5))
plt.plot(epochs, history_final.history['loss'], label='Loss Teste Final', color='tab:purple')
plt.title('Curva de Loss (Modelo Final)')
plt.xlabel('√âpoca')
plt.ylabel('Loss')
plt.legend()
plt.grid()
plt.show()

# Dice
plt.figure(figsize=(8,5))
plt.plot(epochs, history_final.history['dice_coef'], label='Dice Teste Final', color='tab:green')
plt.title('Curva de Dice (Modelo Final)')
plt.xlabel('√âpoca')
plt.ylabel('Dice')
plt.legend()
plt.grid()
plt.show()

def moving_average(data, window=5):
    return np.convolve(data, np.ones(window)/window, mode='valid')

# Dados originais
epochs = np.arange(1, len(history_final.history['loss']) + 1)
loss = history_final.history['loss']
dice = history_final.history['dice_coef']

# Suaviza√ß√£o
window = 5
sm_loss = moving_average(loss, window)
sm_dice = moving_average(dice, window)
sm_epochs = np.arange(window//2 + 1, len(loss) - (window//2) + 1)

# Marcadores apenas em 1, 5, 10, ...
marker_epochs = [e for e in sm_epochs if e == 1 or e % 5 == 0]
marker_indices = [np.where(sm_epochs == me)[0][0] for me in marker_epochs]

# üìâ LOSS
plt.figure(figsize=(8,5))
plt.plot(sm_epochs, sm_loss, color='tab:purple', label='Loss Teste Final')
plt.plot(sm_epochs[marker_indices], sm_loss[marker_indices], 'o', color='tab:purple')
plt.title('Curva de Loss (Modelo Final) - Suavizada')
plt.xlabel('√âpoca')
plt.ylabel('Loss')
plt.legend()
plt.grid()
plt.tight_layout()
plt.show()

# üéØ DICE
plt.figure(figsize=(8,5))
plt.plot(sm_epochs, sm_dice, color='tab:green', label='Dice Teste Final')
plt.plot(sm_epochs[marker_indices], sm_dice[marker_indices], 's', color='tab:green')
plt.title('Curva de Dice (Modelo Final) - Suavizada')
plt.xlabel('√âpoca')
plt.ylabel('Dice')
plt.legend()
plt.grid()
plt.ylim(0, 1)
plt.tight_layout()
plt.show()

# Plot Scatter
lesion_pixels_per_slice_test = [np.sum(y.squeeze()) for y in Y_test]
dice_per_slice_test = [dice_score(y.squeeze(), y_hat.squeeze())
                       for y, y_hat in zip(Y_test, Y_pred_bin_test)]

plt.figure(figsize=(8,5))
plt.scatter(
    np.array(lesion_pixels_per_slice_test)[np.array(lesion_pixels_per_slice_test) > 0],
    np.array(dice_per_slice_test)[np.array(lesion_pixels_per_slice_test) > 0],
    alpha=0.6, color='tab:purple'
)
plt.title("Teste Final: Dice Score vs Tamanho da Les√£o (pixels)")
plt.xlabel("Tamanho da Les√£o (pixels)")
plt.ylabel("Dice Score")
plt.grid(True)
plt.show()

precision, recall, thresholds_pr = precision_recall_curve(all_y_true, all_y_probs)
pr_auc = auc(recall, precision)

plt.figure(figsize=(8, 5))
plt.plot(recall, precision, label=f'PR AUC = {pr_auc:.4f}', color='tab:purple')
plt.title('Curva Precision-Recall - Teste Final (por pixel)')
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.legend()
plt.grid()
plt.show()

print(f"AUC PR (teste): {pr_auc:.4f}")

# Matriz de Confus√£o (por Slice) - Teste Final
threshold = 0.6
y_true_slice = []
y_pred_slice = []

for i in range(len(X_test)):
    mask_true = Y_test[i].squeeze()
    pred_bin = (Y_probs_test[i].squeeze() > threshold).astype(np.uint8)

    has_lesion_gt = int(np.sum(mask_true) > 0)
    has_lesion_pred = int(np.sum(pred_bin) > 0)

    y_true_slice.append(has_lesion_gt)
    y_pred_slice.append(has_lesion_pred)

cm_slice = confusion_matrix(y_true_slice, y_pred_slice, labels=[0, 1])

disp = ConfusionMatrixDisplay(confusion_matrix=cm_slice, display_labels=["Fundo", "Les√£o"])
disp.plot(cmap='Purples', values_format='d')
plt.title(f"Matriz de Confus√£o (por Slice) - Teste Final")
plt.grid(False)
plt.show()

cm_pixel = confusion_matrix(all_y_true, (all_y_probs > threshold).astype(np.uint8), labels=[0, 1])
cm_norm = cm_pixel.astype('float') / cm_pixel.sum(axis=1, keepdims=True)

# Matriz de Confus√£o Normalizada (Pixel) - Teste Final
sns.heatmap(cm_norm, annot=True, cmap='Purples', fmt='.2f',
            xticklabels=['Fundo', 'Les√£o'], yticklabels=['Fundo', 'Les√£o'])
plt.title(f"Matriz de Confus√£o Normalizada (Pixel) - Teste Final")
plt.xlabel("Predito")
plt.ylabel("Real")
plt.show()

Y_test = np.load("/content/drive/MyDrive/TCC/ResultadosUnet/Y_test.npy")
Y_probs_test = np.load("/content/drive/MyDrive/TCC/ResultadosUnet/Y_probs_test.npy")
X_test = np.load("/content/drive/MyDrive/TCC/ResultadosUnet/X_test.npy")

def dice_score(y_true, y_pred, smooth=1e-6):
    y_true_f = y_true.flatten()
    y_pred_f = y_pred.flatten()
    intersection = np.sum(y_true_f * y_pred_f)
    return (2. * intersection + smooth) / (np.sum(y_true_f) + np.sum(y_pred_f) + smooth)

# Plot qualitativo
def plot_qualitativo_teste(idx, title_extra=''):
    mask_true = Y_test[idx].squeeze()
    flair = X_test[idx].squeeze()
    pred_probs = Y_probs_test[idx].squeeze()
    pred_bin = (pred_probs > 0.6).astype(np.uint8)

    # M√©tricas
    dice = dice_score(mask_true, pred_bin)
    iou = jaccard_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
    recall = recall_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
    precision = precision_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
    f1 = f1_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
    cm = confusion_matrix(mask_true.flatten(), pred_bin.flatten(), labels=[0, 1])

    plt.figure(figsize=(15, 4))
    plt.subplot(1, 4, 1)
    plt.title("FLAIR")
    plt.imshow(flair, cmap='viridis')
    plt.axis('off')

    plt.subplot(1, 4, 2)
    plt.title("M√°scara Real")
    plt.imshow(mask_true, cmap='viridis')
    plt.axis('off')

    plt.subplot(1, 4, 3)
    plt.title(f"Predi√ß√£o\nDice: {dice:.4f}")
    plt.imshow(pred_bin, cmap='viridis')
    plt.axis('off')

    plt.subplot(1, 4, 4)
    sns.heatmap(cm, annot=True, fmt='d', cmap='Purples', xticklabels=['Fundo', 'Les√£o'], yticklabels=['Fundo', 'Les√£o'])
    plt.title(f"Matriz de Confus√£o\n{title_extra}")
    plt.xlabel("Predito")
    plt.ylabel("Real")

    plt.tight_layout()
    plt.show()

    print(f"Dice: {dice:.4f}, IoU: {iou:.4f}, Recall: {recall:.4f}, Precision: {precision:.4f}, F1: {f1:.4f}")

# Calcula m√©tricas por slice
lesion_pixels_test = np.array([np.sum(mask.squeeze()) for mask in Y_test])
dice_per_slice_test = np.array([
    dice_score(y.squeeze(), (yp.squeeze() > 0.6).astype(np.uint8))
    for y, yp in zip(Y_test, Y_probs_test)
])

# Slice sem les√£o e sem predi√ß√£o
no_lesion_cases = np.where(lesion_pixels_test == 0)[0]
valid_no_lesion = [i for i in no_lesion_cases if np.sum((Y_probs_test[i].squeeze() > 0.6).astype(np.uint8)) == 0]
if valid_no_lesion:
    plot_qualitativo_teste(valid_no_lesion[0], title_extra='Sem Les√£o - Predi√ß√£o Correta')

# Les√£o pequena (100‚Äì500 pixels)
lesion_small_cases = np.where((lesion_pixels_test > 300) & (lesion_pixels_test < 400))[0]
if len(lesion_small_cases) > 0:
    plot_qualitativo_teste(lesion_small_cases[0], title_extra='Les√£o Pequena')

# Maior les√£o
idx_max_lesion = np.argmax(lesion_pixels_test)
plot_qualitativo_teste(idx_max_lesion, title_extra='Maior Les√£o')

# Maior Dice com les√£o
cases_with_lesion = np.where(lesion_pixels_test > 0)[0]
idx_best_dice = cases_with_lesion[np.argmax(dice_per_slice_test[cases_with_lesion])]
plot_qualitativo_teste(idx_best_dice, title_extra='Maior Dice com Les√£o')

# Plot qualitativo com mapa de erro
def plot_case_qualitativo_teste(idx, title_extra=''):
    mask_true = Y_test[idx].squeeze()
    flair = X_test[idx].squeeze()
    pred_probs = Y_probs_test[idx].squeeze()
    pred_bin = (pred_probs > 0.6).astype(np.uint8)

    # M√©tricas
    dice = dice_score(mask_true, pred_bin)

    if np.sum(mask_true) == 0 and np.sum(pred_bin) == 0:
        # Sem les√£o e sem predi√ß√£o ‚Äî caso perfeito "negativo"
        dice = 1.0
        iou = 1.0
        recall = 1.0
        precision = 1.0
        f1 = 1.0
    else:
        iou = jaccard_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
        recall = recall_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
        precision = precision_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)
        f1 = f1_score(mask_true.flatten(), pred_bin.flatten(), zero_division=0)


    # Mapa de erro
    intersection = np.logical_and(mask_true == 1, pred_bin == 1)
    false_positive = np.logical_and(mask_true == 0, pred_bin == 1)
    false_negative = np.logical_and(mask_true == 1, pred_bin == 0)
    error_map = np.zeros((*mask_true.shape, 3), dtype=np.uint8)
    error_map[intersection] = [0, 255, 0]    # TP - Verde
    error_map[false_positive] = [255, 0, 0]  # FP - Vermelho
    error_map[false_negative] = [0, 0, 255]  # FN - Azul

    plt.figure(figsize=(18, 5))
    plt.subplot(1, 4, 1)
    plt.title("FLAIR")
    plt.imshow(flair, cmap='gray')
    plt.axis('off')

    plt.subplot(1, 4, 2)
    plt.title(f"M√°scara Real\nPixels: {np.sum(mask_true)}")
    plt.imshow(mask_true, cmap='gray')
    plt.axis('off')

    plt.subplot(1, 4, 3)
    plt.title(f"Predi√ß√£o\nDice: {dice:.4f}\nIoU: {iou:.4f}")
    plt.imshow(pred_bin, cmap='gray')
    plt.axis('off')

    plt.subplot(1, 4, 4)
    plt.title("Mapa de Erro\nVerde: TP | Vermelho: FP | Azul: FN")
    plt.imshow(error_map)
    plt.axis('off')

    plt.suptitle(f'{title_extra}', fontsize=16)
    plt.show()

    print(f"Dice: {dice:.4f}, IoU: {iou:.4f}, Recall: {recall:.4f}, Precision: {precision:.4f}, F1: {f1:.4f}")

# Calcula m√©tricas por slice
lesion_pixels_test = np.array([np.sum(mask.squeeze()) for mask in Y_test])
dice_per_slice_test = np.array([
    dice_score(y.squeeze(), (yp.squeeze() > 0.6).astype(np.uint8))
    for y, yp in zip(Y_test, Y_probs_test)
])

# Slice sem les√£o e sem predi√ß√£o
no_lesion_cases = np.where(lesion_pixels_test == 0)[0]
valid_no_lesion = [i for i in no_lesion_cases if np.sum((Y_probs_test[i].squeeze() > 0.6).astype(np.uint8)) == 0]
if valid_no_lesion:
    plot_case_qualitativo_teste(valid_no_lesion[0], title_extra='Sem Les√£o - Predi√ß√£o Correta')

# Les√£o pequena (100‚Äì500 pixels)
lesion_small_cases = np.where((lesion_pixels_test > 300) & (lesion_pixels_test < 400))[0]
if len(lesion_small_cases) > 0:
    plot_case_qualitativo_teste(lesion_small_cases[0], title_extra='Les√£o Pequena')

# Maior les√£o
idx_max_lesion = np.argmax(lesion_pixels_test)
plot_case_qualitativo_teste(idx_max_lesion, title_extra='Maior Les√£o')

# Maior Dice com les√£o
cases_with_lesion = np.where(lesion_pixels_test > 0)[0]
idx_best_dice = cases_with_lesion[np.argmax(dice_per_slice_test[cases_with_lesion])]
plot_case_qualitativo_teste(idx_best_dice, title_extra='Maior Dice com Les√£o')