# -*- coding: utf-8 -*-
"""11913509_TCC_Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xmIdJM8AZaIwnJrUSrKF_3wha1qJpR-k

**Gabriela Sandanieli de Aguiar (11913509) - Engenharia de Computação - USP São Carlos**
"""

from google.colab import drive
drive.mount('/content/drive')

"""# **Pré-processamento das imagens**"""

# Instala as bibliotecas necessárias para o processamento das imagens
!pip install nibabel opencv-python tqdm

# Importa bibliotecas essenciais
import os                    # Para manipulação de arquivos e diretórios
import numpy as np           # Para manipulações numéricas
import nibabel as nib        # Para leitura de arquivos NIfTI (.nii/.nii.gz)
import cv2                   # OpenCV para processamento de imagem
from tqdm import tqdm        # Barra de progresso para loops

def normalize(img):
    # Converte para float32 para evitar problemas com divisões inteiras
    img = img.astype(np.float32)

    # Normaliza os valores entre 0 e 1, depois escala para 0-255
    img = (img - np.min(img)) / (np.max(img) - np.min(img) + 1e-8)
    return (img * 255).astype(np.uint8)

def resize_and_pad(img, size=256):
    h, w = img.shape  # Altura e largura originais
    scale = size / max(h, w)  # Escala baseada na maior dimensão
    resized = cv2.resize(img, (int(w * scale), int(h * scale)))  # Redimensiona mantendo proporção

    # Calcula quanto de padding adicionar em cada lado
    h_pad = (size - resized.shape[0]) // 2
    w_pad = (size - resized.shape[1]) // 2

    # Aplica padding com bordas pretas (valor 0)
    padded = cv2.copyMakeBorder(resized, h_pad, size - resized.shape[0] - h_pad,
                                w_pad, size - resized.shape[1] - w_pad,
                                cv2.BORDER_CONSTANT, value=0)
    return padded

def save_slices(patient_id, flair_nii, mask_nii=None, num_slices=20):
    flair_data = nib.load(flair_nii).get_fdata()  # Carrega volume FLAIR
    flair_data = np.transpose(flair_data, (2, 0, 1))  # Reorganiza eixos: (slices, altura, largura)

    if mask_nii:
        mask_data = nib.load(mask_nii).get_fdata()
        mask_data = np.transpose(mask_data, (2, 0, 1))
    else:
        mask_data = np.zeros_like(flair_data)  # Se não houver máscara, usa zeros

    # Define diretórios de saída
    output_patient_dir = os.path.join(output_dir, patient_id)
    flair_out = os.path.join(output_patient_dir, "flair")
    mask_out = os.path.join(output_patient_dir, "mask")

    os.makedirs(flair_out, exist_ok=True)
    if np.sum(mask_data) > 0:
        os.makedirs(mask_out, exist_ok=True)

    # Seleciona slices com lesões (se houver máscara), ou 20 centrais (se não houver)
    if mask_nii and np.sum(mask_data) > 0:
        valid_slices = [i for i in range(mask_data.shape[0]) if np.sum(mask_data[i]) > 0]
        selected_slices = sorted(valid_slices)
        print(f"[INFO] {patient_id}: {len(selected_slices)} slices com lesão salvas.")
    else:
        center = flair_data.shape[0] // 2
        half = num_slices // 2
        selected_slices = list(range(center - half, center + half))
        print(f"[INFO] {patient_id}: 20 slices centrais salvas (saudável).")

    # Processa e salva cada slice
    for idx, slice_idx in enumerate(selected_slices):
        flair_slice = normalize(flair_data[slice_idx])
        mask_slice = normalize(mask_data[slice_idx]) if mask_nii else np.zeros_like(flair_slice)

        # Rotaciona para padronizar orientação
        flair_slice = cv2.rotate(flair_slice, cv2.ROTATE_90_COUNTERCLOCKWISE)
        mask_slice = cv2.rotate(mask_slice, cv2.ROTATE_90_COUNTERCLOCKWISE)

        # Redimensiona com padding
        flair_slice = resize_and_pad(flair_slice, size=256)
        mask_slice = resize_and_pad(mask_slice, size=256)

        # Gera nomes dos arquivos
        flair_name = f"{patient_id}-slice-{idx+1:02}.png"
        mask_name = f"{patient_id}-mask-{idx+1:02}.png"

        # Salva as imagens
        cv2.imwrite(os.path.join(flair_out, flair_name), flair_slice)
        if mask_nii and np.sum(mask_data) > 0:
            cv2.imwrite(os.path.join(mask_out, mask_name), mask_slice)

input_dir = "/content/drive/MyDrive/TCC"
output_dir = "/content/drive/MyDrive/TCC/slices_subs"
os.makedirs(output_dir, exist_ok=True)

# Processa os pacientes
sub_dirs = sorted([d for d in os.listdir(input_dir) if d.startswith("sub-")])
print(f"Encontrados {len(sub_dirs)} pacientes.")

for sub in tqdm(sub_dirs):
    anat_dir = os.path.join(input_dir, sub, "anat")
    if not os.path.exists(anat_dir):
        continue

    flair_file = None
    mask_file = None

    # Identifica os arquivos FLAIR e ROI (máscara)
    for file in os.listdir(anat_dir):
        if file.endswith("_FLAIR.nii.gz") and "roi" not in file:
            flair_file = os.path.join(anat_dir, file)
        elif file.endswith("_FLAIR_roi.nii.gz"):
            mask_file = os.path.join(anat_dir, file)

    if flair_file is None:
        print(f"[ERRO] FLAIR não encontrado para {sub}, pulando.")
        continue

    if mask_file and not os.path.exists(mask_file):
        print(f"[AVISO] Máscara esperada mas não encontrada para {sub}.")
        mask_file = None

    # Executa o salvamento dos slices
    save_slices(sub, flair_file, mask_file)

slices_dir = "/content/drive/MyDrive/TCC/slices_subs"

com_mascara = 0
sem_mascara = 0
pacientes_com_mascara = 0
pacientes_sem_mascara = 0

# Conta quantos pacientes e imagens têm ou não máscara
for sub in sorted(os.listdir(slices_dir)):
    sub_path = os.path.join(slices_dir, sub)
    flair_path = os.path.join(sub_path, "flair")
    mask_path = os.path.join(sub_path, "mask")

    if os.path.exists(mask_path):
        n = len([f for f in os.listdir(mask_path) if f.endswith(".png")])
        com_mascara += n
        pacientes_com_mascara += 1
    else:
        n = len([f for f in os.listdir(flair_path) if f.endswith(".png")])
        sem_mascara += n
        pacientes_sem_mascara += 1

# Mostra resumo
print(f"Pacientes com máscara: {pacientes_com_mascara}")
print(f"Imagens com máscara:   {com_mascara}")
print(f"Pacientes sem máscara: {pacientes_sem_mascara}")
print(f"Imagens sem máscara:   {sem_mascara}")
print(f"Total de imagens:      {com_mascara + sem_mascara}")

"""# **Gráficos**"""

# Imports necessários
import os
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import imageio

# Caminho base do dataset
base_dir = "/content/drive/MyDrive/TCC/slices_subs"

# Inicializa listas
slices_por_paciente = []
slices_com_lesao = []
slices_sem_lesao = []
pixel_lesionados_por_slice = []

# Percorre pacientes
for paciente in sorted(os.listdir(base_dir)):
    paciente_path = os.path.join(base_dir, paciente)
    flair_dir = os.path.join(paciente_path, "flair")
    mask_dir = os.path.join(paciente_path, "mask")

    if not os.path.isdir(flair_dir):
        continue

    # Conta número total de slices FLAIR
    flair_slices = len([f for f in os.listdir(flair_dir) if f.endswith(".png")])
    slices_por_paciente.append(flair_slices)

    # Máscaras
    if os.path.exists(mask_dir):
        mask_files = sorted([f for f in os.listdir(mask_dir) if f.endswith(".png")])
        slices_com_lesao.append(len(mask_files))
        slices_sem_lesao.append(flair_slices - len(mask_files))

        # Conta pixels lesionados por slice
        for mask_file in mask_files:
            mask_path = os.path.join(mask_dir, mask_file)
            mask = imageio.imread(mask_path)

            if mask.ndim == 3:
                mask = mask[..., 0]  # se RGB, pega canal único

            pixel_lesionados_por_slice.append(np.sum(mask == 255))
    else:
        slices_com_lesao.append(0)
        slices_sem_lesao.append(flair_slices)

# GRÁFICO 1: Slices por paciente
plt.figure(figsize=(12, 5))
plt.bar(range(len(slices_por_paciente)), slices_com_lesao, label='Com Lesão', color='tab:purple')
plt.bar(range(len(slices_por_paciente)), slices_sem_lesao, bottom=slices_com_lesao, label='Sem Lesão', color='tab:green')
plt.xlabel("Paciente")
plt.ylabel("Quantidade de Slices")
plt.title("Distribuição de Slices por Paciente")
plt.legend()
plt.tight_layout()
plt.show()

# GRÁFICO 2: Proporção de slices
total_com_lesao = sum(slices_com_lesao)
total_sem_lesao = sum(slices_sem_lesao)

plt.figure(figsize=(6, 6))
plt.pie([total_com_lesao, total_sem_lesao],
        labels=["Com Lesão", "Sem Lesão"],
        autopct='%1.1f%%',
        colors=['tab:purple', 'tab:green'],
        startangle=140)
plt.title("Proporção de Slices com e sem Lesão")
plt.axis('equal')
plt.tight_layout()
plt.show()

# GRÁFICO 3: Histograma de pixels lesionados
if pixel_lesionados_por_slice:
    plt.figure(figsize=(10, 5))
    sns.histplot(pixel_lesionados_por_slice, bins=20, kde=True, color='tab:purple')
    plt.title("Distribuição de Pixels Lesionados por Slice")
    plt.xlabel("Pixels Lesionados")
    plt.ylabel("Número de Slices")
    plt.tight_layout()
    plt.show()